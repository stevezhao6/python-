剖<div class="post-body" itemprop="articleBody">

      
      

      
        <p>在上一篇文章中，我们提到了aiohttp官方文档中的默认写法速度与requests单线程请求没有什么区别，需要通过使用<code>asyncio.wait</code>来加速aiohttp的请求。今天我们来探讨一下这背后的原因。</p>
<a id="more"/>
<p>我们使用一个可以通过URL设定返回延迟的网站来进行测试，网址为：<code>http://httpbin.org/delay/5</code>。当<code>delay</code>后面的数字为5时，表示请求这个网址以后，要等5秒才会收到返回；当<code>delay</code>后面的数字为3时，表示请求这个网址以后，要等3秒才会收到返回。大家可以在浏览器上面输入这个网址测试看看。</p>
<p>现在我们写一段简单的aiohttp代码来进行测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br/><span class="line"><span class="keyword">import</span> aiohttp</span><br/><span class="line"><span class="keyword">import</span> time</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br/><span class="line">        start = time.time()</span><br/><span class="line">        <span class="keyword">await</span> session.get(<span class="string">'http://httpbin.org/delay/3'</span>)</span><br/><span class="line">        <span class="keyword">await</span> session.get(<span class="string">'http://httpbin.org/delay/5'</span>)</span><br/><span class="line">        end = time.time()</span><br/><span class="line">        print(<span class="string">f'总共耗时：<span class="subst">{end - start}</span>'</span>)</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line">asyncio.run(main())  <span class="comment"># Python 3.7或以上程序直接执行这一行即可运行</span></span><br/><span class="line"/><br/><span class="line"><span class="comment"># Python 3.6或以下需要注释掉上面一行，并为下面两行解除注释</span></span><br/><span class="line"><span class="comment">#loop = asyncio.get_event_loop()</span></span><br/><span class="line"><span class="comment">#loop.run_until_complete(main())</span></span><br/></pre></td></tr></table></figure>
<p>注意，如果你的Python 版本大于等于3.7，那么你可以直接使用<code>asyncio.run</code>来运行一个协程，而不需要像昨天那样先创建一个事件循环再运行。</p>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-28-34.png" alt=""/></p>
<p>可以看到，运行时间大于8秒钟，也就是说，这段代码，是先请求第一个3秒的网址，等它运行完成以后，再请求第二个5秒的网址，他们根本就没有并行！</p>
<p>按照我们之前的认识，协程在网络 IO 等待的时候，可以交出控制权，当 aiohttp 请求第一个3秒网址，等待返回的时候，应该就可以立刻请求第二个5秒的网址。在等待5秒网址返回的过程中，又去检查第一个3秒请求是否结束了。直到3秒请求已经返回了结果，再等待5秒的请求。</p>
<p>那为什么上面这段代码，并没有按这段逻辑来走？</p>
<p>这是因为，协程虽然可以充分利用网络 IO 的等待时间，但它并不会自动这么做。而是需要你把它加入到调度器里面。</p>
<p>能被 <code>await</code>的对象有3种：协程、Task对象、future 对象。</p>
<p>当你<code>await 协程</code>对象时，它并没有被加入到调度器中，所以它依然是串行执行的。</p>
<p>但 Task 对象会被自动加入到调度器中，所以 Task 对象能够并发执行。</p>
<p>要创建一个 Task 对象非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">asyncio.create_task(协程) <span class="comment">#python 3.7或以上版本的写法</span></span><br/><span class="line">asyncio.ensure_future(协程)  <span class="comment"># python 3.6或以下的写法</span></span><br/></pre></td></tr></table></figure>
<p>所以我们来稍稍修改一下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br/><span class="line"><span class="keyword">import</span> aiohttp</span><br/><span class="line"><span class="keyword">import</span> time</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br/><span class="line">        start = time.time()</span><br/><span class="line">        task1 = asyncio.create_task(session.get(<span class="string">'http://httpbin.org/delay/3'</span>))</span><br/><span class="line">        task2 = asyncio.create_task(session.get(<span class="string">'http://httpbin.org/delay/5'</span>))</span><br/><span class="line">        <span class="keyword">await</span> task1</span><br/><span class="line">        <span class="keyword">await</span> task2</span><br/><span class="line">        end = time.time()</span><br/><span class="line">        print(<span class="string">f'总共耗时：<span class="subst">{end - start}</span>'</span>)</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line">asyncio.run(main())  <span class="comment"># Python 3.7或以上程序直接执行这一行即可运行</span></span><br/></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-37-55.png" alt=""/></p>
<p>可以看到，现在请求两个网址的时间加到一起，只比5秒多一点，说明确实已经实现了并发请求的效果。至于这多出来的一点点时间，是因为协程之间切换控制权导致的。</p>
<p>那么为什么我们把很多协程放进一个 列表里面，然后把列表放进 <code>asyncio.wait</code>里面，也能实现并行呢？这是因为，<code>asyncio.wait</code>帮我们做了创建 Task 的任务。这一点我们可以在Python 的<a href="https://docs.python.org/3/library/asyncio-task.html#waiting-primitives" target="_blank" rel="noopener">官方文档</a>中看到原话：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-43-35.png" alt=""/></p>
<p>同理，当你把协程传入<code>asyncio.gather</code>时，这些协程也会被当做Task 来调度：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-19-12-45-34.png" alt=""/></p>
<p>回到我们昨天的问题，我们不用<code>asyncio.wait</code>也不用<code>asyncio.Queue</code>让爬虫并发起来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br/><span class="line"><span class="keyword">import</span> aiohttp</span><br/><span class="line"/><br/><span class="line">template = <span class="string">'http://exercise.kingname.info/exercise_middleware_ip/{page}'</span></span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(session, page)</span>:</span></span><br/><span class="line">    url = template.format(page=page)</span><br/><span class="line">    resp = <span class="keyword">await</span> session.get(url)</span><br/><span class="line">    print(<span class="keyword">await</span> resp.text(encoding=<span class="string">'utf-8'</span>))</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br/><span class="line">        tasks = []</span><br/><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br/><span class="line">            task = asyncio.create_task(get(session, page))</span><br/><span class="line">            tasks.append(task)</span><br/><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br/><span class="line">            <span class="keyword">await</span> task</span><br/><span class="line"/><br/><span class="line">asyncio.run(main())</span><br/></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/new-fast.2019-12-19 12_56_10.gif" alt=""/></p>
<p>但你需要注意一点，创建 Task 与<code>await Task</code>是分开执行的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line">tasks = []</span><br/><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br/><span class="line">    task = asyncio.create_task(get(session, page))</span><br/><span class="line">    tasks.append(task)</span><br/><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br/><span class="line">    <span class="keyword">await</span> task</span><br/></pre></td></tr></table></figure>
<p>你不能写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br/><span class="line">    task = asyncio.create_task(get(session, page))</span><br/><span class="line">    <span class="keyword">await</span> task</span><br/></pre></td></tr></table></figure>
<p>这是因为，创建Task 的时候会自动把它加入到调度队列里面，然后<code>await Task</code>的时候执行调度。上面这样写，会导致每一个 Task 被分批调度，一个 Task 在等待网络 IO 的时候，没有办法切换到第二个 Task，所以最终又会降级成串行请求。</p>

      
    </div>

    

    
    
    

    
      
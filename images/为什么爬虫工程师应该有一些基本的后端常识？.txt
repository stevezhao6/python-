为<div class="post-body" itemprop="articleBody">

      
      

      
        <p>今天在粉丝交流群里面，有个同学说他发现了<code>Requests</code>的一个 bug，并修复了它：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-28-54.png" alt=""/></p>
<p>聊天记录中对应的图片为：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-29-19.png" alt=""/></p>
<p>看到这个同学的截图，我大概知道他遇到了什么问题，以及为什么会误认为这是 Requests 的 bug。</p>
<a id="more"/>
<p>要解释这个问题，我们需要首先明白一个问题，那就是 JSON 字符串的两种显示形式和<code>json.dumps</code>的<code>ensure_ascii</code>参数。</p>
<p>假设我们在 Python 里面有一个字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">info = {<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>}</span><br/></pre></td></tr></table></figure>
<p>当我们想把它转成 JSON 字符串的时候，我们可能会这样写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br/><span class="line">info = {<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>}</span><br/><span class="line">info_str = json.dumps(info)</span><br/><span class="line">print(info_str)</span><br/></pre></td></tr></table></figure>
<p>运行效果如下图所示，中文变成了 Unicode 码：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-33-18.png" alt=""/></p>
<p>我们也可以增加一个参数<code>ensure_ascii=False</code>，让中文正常显示出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">info_str = json.dumps(info, ensure_ascii=<span class="literal">False</span>)</span><br/></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-34-30.png" alt=""/></p>
<p>这位同学认为，由于<code>{"name": "\u9752\u5357", "age": 20}</code>和<code>{"name": "青南", "age": 20}</code>从字符串角度看，显然不相等。而 Requests 在 POST 发送数据的时候，默认是没有这个参数，而对<code>json.dumps</code>来说，省略这个参数等价于<code>ensure_ascii=True</code>：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-37-27.png" alt=""/></p>
<p>所以实际上<code>Requests</code>在 POST 含有中文的数据时，会把中文转成 Unicode 码发给服务器，于是服务器根本就拿不到原始的中文信息了。所以就会导致报错。</p>
<p>但实际上，并不是这样的。我常常跟群里的同学说，做爬虫的同学，应该要有一些基本的后端常识，才不至于被这种现象误导。为了说明为什么上面这个同学的理解是错误的，为什么这不是 Requests 的 bug，我们自己来写一个含有 POST 的服务，来看看我们POST 两种情况的数据有没有区别。为了证明这个特性与网络框架无关，我这里分别使用Flask、Fastapi 、Gin 来进行演示。</p>
<p>首先，我们来看看Requests 测试代码。这里用3种方式发送了 JSON 格式的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br/><span class="line"><span class="keyword">import</span> json </span><br/><span class="line"/><br/><span class="line">body = {</span><br/><span class="line">    <span class="string">'name'</span>: <span class="string">'青南'</span>,</span><br/><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br/><span class="line">}</span><br/><span class="line">url = <span class="string">'http://127.0.0.1:5000/test_json'</span></span><br/><span class="line"/><br/><span class="line"><span class="comment"># 直接使用 json=的方式发送</span></span><br/><span class="line">resp = requests.post(url, json=body).json() </span><br/><span class="line">print(resp)</span><br/><span class="line"/><br/><span class="line">headers = {</span><br/><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br/><span class="line">}</span><br/><span class="line"/><br/><span class="line"><span class="comment"># 提前把字典序列化成 JSON 字符串，中文转成 Unicode，跟第一种方式等价</span></span><br/><span class="line">resp = requests.post(url,</span><br/><span class="line">                     headers=headers,</span><br/><span class="line">                     data=json.dumps(body)).json()</span><br/><span class="line">print(resp)</span><br/><span class="line"/><br/><span class="line"><span class="comment"># 提前把字典序列化成 JSON 字符串，中文保留</span></span><br/><span class="line">resp = requests.post(url,</span><br/><span class="line">                     headers=headers,</span><br/><span class="line">                     data=json.dumps(body, ensure_ascii=<span class="literal">False</span>).encode()).json()</span><br/><span class="line">print(resp)</span><br/></pre></td></tr></table></figure>
<p>这段测试代码使用3种方式发送 POST 请求，其中，第一种方法就是 Requests 自带的<code>json=</code>参数，参数值是一个字典。Requests 会自动把它转成 JSON 字符串。后两种方式，是我们手动提前把字典转成 JSON 字符串，然后使用<code>data=</code>参数发送给服务器。这两种方式需要在 Headers 里面指明<code>'Content-Type': 'application/json'</code>，服务器才知道发上来的是 JSON 字符串。</p>
<p>我们再来看看 Flask 写的后端代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br/><span class="line">app = Flask(__name__)</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="meta">@app.route('/')</span></span><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">return</span> {<span class="string">'success'</span>: <span class="literal">True</span>}</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="meta">@app.route('/test_json', methods=["POST"])</span></span><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">()</span>:</span></span><br/><span class="line">    body = request.json </span><br/><span class="line">    msg = <span class="string">f'收到 POST 数据，<span class="subst">{body[<span class="string">"name"</span>]=}</span>, <span class="subst">{body[<span class="string">"age"</span>]=}</span>'</span></span><br/><span class="line">    print(msg)</span><br/><span class="line">    <span class="keyword">return</span> {<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: msg}</span><br/></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-51-17.png" alt=""/></p>
<p>可以看到，无论使用哪种 POST 方式，后端都能接收到正确的信息。</p>
<p>我们再来看 Fastapi 版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br/><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel </span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span><span class="params">(BaseModel)</span>:</span></span><br/><span class="line">    name: str</span><br/><span class="line">    age: int </span><br/><span class="line"/><br/><span class="line">app = FastAPI()</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="meta">@app.get('/')</span></span><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">return</span> {<span class="string">'success'</span>: <span class="literal">True</span>}</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="meta">@app.post('/test_json')</span></span><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_json</span><span class="params">(body: Body)</span>:</span></span><br/><span class="line">    msg = <span class="string">f'收到 POST 数据，<span class="subst">{body.name=}</span>, <span class="subst">{body.age=}</span>'</span></span><br/><span class="line">    print(msg)</span><br/><span class="line">    <span class="keyword">return</span> {<span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: msg}</span><br/></pre></td></tr></table></figure>
<p>运行效果如下图所示，三种 POST 发送的数据，都能被后端正确识别：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-53-52.png" alt=""/></p>
<p>我们再来看看 Gin 版本的后端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br/><span class="line"/><br/><span class="line"><span class="keyword">import</span> (</span><br/><span class="line">    <span class="string">"fmt"</span></span><br/><span class="line">    <span class="string">"net/http"</span></span><br/><span class="line"/><br/><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br/><span class="line">)</span><br/><span class="line"/><br/><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> {</span><br/><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br/><span class="line">    Age  <span class="keyword">int16</span>  <span class="string">`json:"age"`</span></span><br/><span class="line">}</span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br/><span class="line">    r := gin.Default()</span><br/><span class="line">    r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br/><span class="line">        c.JSON(http.StatusOK, gin.H{</span><br/><span class="line">            <span class="string">"message"</span>: <span class="string">"running"</span>,</span><br/><span class="line">        })</span><br/><span class="line">    })</span><br/><span class="line">    r.POST(<span class="string">"/test_json"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br/><span class="line">        json := Body{}</span><br/><span class="line">        c.BindJSON(&amp;json)</span><br/><span class="line">        msg := fmt.Sprintf(<span class="string">"收到 POST 数据，name=%s, age=%d"</span>, json.Name, json.Age)</span><br/><span class="line">        fmt.Println(<span class="string">"&gt;&gt;&gt;"</span>, msg)</span><br/><span class="line">        c.JSON(http.StatusOK, gin.H{</span><br/><span class="line">            <span class="string">"msg"</span>: fmt.Sprintf(<span class="string">"收到 POST 数据，name=%s, age=%d"</span>, json.Name, json.Age),</span><br/><span class="line">        })</span><br/><span class="line">    })</span><br/><span class="line">    r.Run()</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>运行效果如下，三种请求方式的数据完全相同：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-15-56-23.png" alt=""/></p>
<p>从这里可以知道，无论我们 POST 提交的 JSON 字符串中，中文是以 Unicode 码的形式存在还是直接以汉字的形式存在，后端服务都可以正确解析。</p>
<p>为什么我说中文在 JSON 字符串里面以哪种形式显示并不重要呢？这是因为，对 JSON 字符串来说，编程语言把它重新转换为对象的过程（叫做<code>反序列化</code>），本身就可以正确处理他们。我们来看下图：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2021-06-19-16-05-25.png" alt=""/></p>
<p><code>ensure_ascii</code>参数的作用，仅仅控制的是 JSON 的显示样式，当<code>ensure_ascii</code>为<code>True</code>的时候，确保 JSON 字符串里面只有 ASCII 字符，所以不在 ASCII 128个字符内的字符，都会被转换。而当<code>ensure_ascii</code>为<code>False</code>的时候，这些非 ASCII 字符依然以原样显示。这就像是一个人化妆和不化妆一样，本质并不会改变。现代化的编程语言在对他们进行反序列化的时候，两种形式都能正确识别。</p>
<p>所以，如果你是用现代化的 Web 框架来写后端，那么这两种 JSON 形式应该是没有任何区别的。Request 默认的<code>json=</code>参数，相当于<code>ensure_ascii=True</code>，任何现代化的 Web 框架都能正确识别 POST 提交上来的内容。</p>
<p>当然，如果你使用的是 C 语言、汇编或者其他语言来裸写后端接口，那确实可能有所差别。可智商正常的人，谁会这样做？</p>
<p>综上所述，这位同学遇到的问题，并不是 Requests 的 bug，而是他的后端接口本身有问题。可能那个后端使用了某种弱智 Web 框架，它接收到的被 POST 发上来的信息，没有经过反序列化，就是一段 JSON 字符串，而那个后端程序员使用正则表达式从 JSON 字符串里面提取数据，所以当发现 JSON 字符串里面没有中文的时候，就报错了。</p>
<p>除了这个 POST 发送 JSON 的问题，以前我有个下属，在使用 Scrapy 发送 POST 信息的时候，由于不会写POST 的代码，突发奇想，把 POST 发送的字段拼接到 URL 上，然后用 GET 方式请求，发现也能获取数据，类似于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">body = {<span class="string">'name'</span>: <span class="string">'青南'</span>, <span class="string">'age'</span>: <span class="number">20</span>}</span><br/><span class="line">url = <span class="string">'http://www.xxx.com/api/yyy'</span></span><br/><span class="line">requests.post(url, json=body).text</span><br/><span class="line"/><br/><span class="line">requests.get(<span class="string">'http://www.xxx.com/api/yyy?name=青南&amp;age=20'</span>).text</span><br/></pre></td></tr></table></figure>
<p>于是，这个同学得出一个结论，他认为这是一个普遍的规律，所有 POST 的请求都可以这样转到 GET 请求。</p>
<p>但显然，这个结论也是不正确的。这只能说明，这个网站的后端程序员，让这个接口能同时兼容两种提交数据的方式，这是需要后端程序员额外写代码来实现的。在默认情况下，GET 和 POST 是两种完全不同的请求方式，也不能这样转换。</p>
<p>如果这位同学会一些简单的后端，那么他立刻就可以写一个后端程序来验证自己的猜想。</p>
<p>再来一个例子，有一些网站，他们在 URL 中可能会包含另外一个 URL，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">https://kingname.info/get_info?url=https://abc.com/def/xyz?id=123&amp;db=admin</span><br/></pre></td></tr></table></figure>
<p>如果你没有基本的后端知识，那么你可能看不出上面的网址有什么问题。但是如果你有一些基本的后端常识，那么你可能会问一个问题：网址中的<code>&amp;db=admin</code>，是属于<code>https://kingname.info/get_info</code>的一个参数，跟<code>url=</code>平级；还是属于<code>https://abc.com/def/xyz?id=123&amp;db=admin</code>的参数？你会疑惑，后端也会疑惑，所以这就是为什么我们这个时候需要 urlencode 的原因，毕竟下面两种写法，是完全不一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">https://kingname.info/get_info?url=https%3A%2F%2Fabc.com%2Fdef%2Fxyz%3Fid%3D123%26db%3Dadmin</span><br/><span class="line"/><br/><span class="line">https://kingname.info/get_info?url=https%3A%2F%2Fabc.com%2Fdef%2Fxyz%3Fid%3D123&amp;db=admin</span><br/></pre></td></tr></table></figure>
<p>最后，以我的爬虫书序言中的一句话来作为总结：</p>
<blockquote>
<p>爬虫是一门杂学，如果你只会爬虫，那么你是学不好爬虫的。</p>
</blockquote>

      
    </div>

    

    
    
    

    
      
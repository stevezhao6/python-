炸<div class="post-body" itemprop="articleBody">

      
      

      
        <p>在上一篇文章中，我们讲到了，使用<code>itertools.tee</code>可以让一个生成器被多次完整遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools </span><br/><span class="line"/><br/><span class="line">g = generator()</span><br/><span class="line">g_1, g_2, g_3 = itertools.tee(g, <span class="number">3</span>)</span><br/><span class="line"/><br/><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> g_1:</span><br/><span class="line">    print(row)</span><br/><span class="line"/><br/><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> g_2:</span><br/><span class="line">    print(row)</span><br/><span class="line">    </span><br/><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> g_3:</span><br/><span class="line">    print(row)</span><br/></pre></td></tr></table></figure>
<p>但是，我们说到<code>itertools.tee</code>有两个弊端，其一，如果分裂出来的多个生成器是按顺序执行的，其中一个完整遍历了再遍历第二个，那么就会导致内存中堆积大量的数据。</p>
<p>要解释这个问题的原因，我们就要理解<code>itertools.tee</code>背后的原理。</p>
<a id="more"/>
<p>我们知道，一个生成器只能被完整遍历一次。那么如果我想强行让他被遍历两次怎么办呢？最简单的办法是搞个列表出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line">g = generator()</span><br/><span class="line">value_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> g]</span><br/><span class="line"/><br/><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> value_list:</span><br/><span class="line">    print(row)</span><br/><span class="line"/><br/><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> value_list:</span><br/><span class="line">    print(row)</span><br/></pre></td></tr></table></figure>
<p>转换为列表以后，你想完整遍历几次，就能完整遍历几次。但这样做，就背离了使用生成器节省内存的目的。所有的数据，全都在列表里面，如果数据量非常非常多，那么内存可能就会爆炸。</p>
<p>所以我们需要一边迭代生成器，一边消费数据。为了实现这个目的，我们先来看看，如何一条一条地取出生成器里面的数据——<code>next</code> 函数。</p>
<p>当我们每次执行<code>next(g)</code>的时候，生成器被迭代1次，并返回1条数据，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-21-25-21.png" alt=""/></p>
<p>当生成器的所有数据都被遍历完成以后，再次执行<code>next(g)</code>就会抛出<code>StopIteration</code>异常。所以当我们捕获到这个异常的时候，就说明生成器里面的所有数据都遍历完成了。</p>
<p>现在，我们把生成器<code>分裂出来</code>，但是取极端情况，只分裂1个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br/><span class="line">        <span class="keyword">yield</span> <span class="string">f'我是你第<span class="subst">{i}</span>个爷爷'</span></span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(g)</span>:</span></span><br/><span class="line">    value_list = []</span><br/><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br/><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value_list:</span><br/><span class="line">            <span class="keyword">try</span>:</span><br/><span class="line">                value = next(g)</span><br/><span class="line">            <span class="keyword">except</span> StopIteration:</span><br/><span class="line">                <span class="keyword">return</span></span><br/><span class="line">            value_list.append(value)</span><br/><span class="line">        <span class="keyword">yield</span> value_list.pop()</span><br/><span class="line"/><br/><span class="line">g = generator()</span><br/><span class="line">g_1 = split(g)</span><br/><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_1:</span><br/><span class="line">    print(value)</span><br/></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-21-31-28.png" alt=""/></p>
<p><code>split</code>生成器函数，写了一大堆代码，似乎做了无用功——如果<code>value_list</code>为空，那么就从原始生成器里面取一个数据，然后放入 <code>value_list</code> 列表，然后又把这个数从 <code>value_list</code>取出来，再抛给上层。</p>
<p>这样写有什么意义呢？</p>
<p>现在，我们修改代码，让 split 能够分裂出两个生成器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br/><span class="line">        <span class="keyword">yield</span> <span class="string">f'我是你第<span class="subst">{i}</span>个爷爷'</span></span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(g)</span>:</span></span><br/><span class="line">    value_list_1 = []</span><br/><span class="line">    value_list_2 = []</span><br/><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(queue)</span>:</span></span><br/><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br/><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue:</span><br/><span class="line">                <span class="keyword">try</span>:</span><br/><span class="line">                    value = next(g)</span><br/><span class="line">                <span class="keyword">except</span> StopIteration:</span><br/><span class="line">                    <span class="keyword">return</span></span><br/><span class="line">                value_list_1.append(value)</span><br/><span class="line">                value_list_2.append(value)</span><br/><span class="line">            <span class="keyword">yield</span> queue.pop(<span class="number">0</span>)</span><br/><span class="line">    g_1 = wrap(value_list_1)</span><br/><span class="line">    g_2 = wrap(value_list_2)</span><br/><span class="line">    <span class="keyword">return</span> g_1, g_2</span><br/><span class="line"/><br/><span class="line">g = generator()</span><br/><span class="line">g_1, g_2 = split(g)</span><br/><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_1:</span><br/><span class="line">    print(value)</span><br/><span class="line"/><br/><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_2:</span><br/><span class="line">    print(value)</span><br/></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-21-42-29.png" alt=""/></p>
<p>现在， <code>split</code>是一个会返回两个生成器的函数。首先创建两个列表<code>value_list_1</code>和<code>value_list_2</code>，然后定义一个闭包生成器函数<code>wrap</code>。它接收一个参数<code>queue</code>。这个参数是一个列表。</p>
<p>如果<code>queue</code>不为空，那么取它的第0个元素，并抛出给上层。如果<code>queue</code>为空，迭代一次原始生成器，获得的值同时放进<code>value_list_1</code>和<code>value_list_2</code>这两个列表中。此时，由于<code>queue</code>列表必定是<code>value_list_1</code>或者<code>value_list_2</code>的其中一个，所以此时<code>queue</code>必定不为空，因此可以取它下标为0的元素，抛出给上层。</p>
<p>由于<code>.pop</code>在取出数据以后，会把这个数据从列表里面删除。所以<code>queue</code>对应的列表又会变成空。</p>
<p>但大家有没有发现，此时，另外一个列表的数据，是留在列表里面的，没有被消费。</p>
<p>所以，如果我始终迭代<code>g_1</code>这个分裂后的生成器，那么<code>wrap</code>的参数始终是<code>value_list_1</code>，此时，<code>value_list_2</code>始终没有被消费，于是数据就会越堆越多，最后撑爆内存。</p>
<p>所以，<code>itertools.tee</code>分裂以后的多个生成器，应该尽量间隔着迭代，或者“同时迭代”，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br/><span class="line">    <span class="keyword">try</span>:</span><br/><span class="line">        value = next(g_1)</span><br/><span class="line">        parse(value)</span><br/><span class="line">        value = next(g_2)</span><br/><span class="line">        parse(value)</span><br/><span class="line">    <span class="keyword">except</span> StopIteration:</span><br/><span class="line">        <span class="keyword">break</span></span><br/></pre></td></tr></table></figure>
<p>这样调用，就能始终保证两个列表最多只有1条数据，就不会出现堆积的问题。</p>
<p>但是在实际项目中，很难这样写，所以你可能会想，是不是可以把分裂后的多个生成器，放进多个线程里面同步运行。这样虽然列表里面的数据会超过1条，但也不会堆积太多。</p>
<p>然而这是不行的，<code>itertools.tee</code>分裂出来的多个生成器不是线程安全的，不能在多线程里面运行，否则会导致报错。这里给出一个报错的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br/><span class="line"><span class="keyword">import</span> threading</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br/><span class="line">        <span class="keyword">yield</span> i</span><br/><span class="line"/><br/><span class="line">g = generator()</span><br/><span class="line">g_1, g_2 = itertools.tee(g, <span class="number">2</span>)</span><br/><span class="line"/><br/><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [g_1, g_2]:</span><br/><span class="line">    threading.Thread(target=sum, args=(x, )).start()</span><br/></pre></td></tr></table></figure>
<p>运行效果如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-22-04-16.png" alt=""/></p>
<p>在下一篇文章中，我们将会说明，为什么分裂以后的生成器不是线程安全的，以及如何让它线程安全。</p>
<p>P.S.:本文介绍 <code>itertools.tee</code>的代码经过简化和修改，用于表示这个函数的核心逻辑。但真正的源代码比这个简化版本要复杂得多。并且源代码中队列是使用<code>dequeue</code>而不是列表。因为<code>dequeue</code>是基于双向链表实现的，在两头增加删除数据，时间复杂度都是 O(1)，但是从列表的头部删除数据，时间复杂度为 O(n)。</p>

      
    </div>

    

    
    
    

    
      
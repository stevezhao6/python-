使<div class="post-body" itemprop="articleBody">

      
      

      
        <p>假设有一个 Redis 集合，里面有 N 条数据，你不停从里面<code>lpop</code>数据，直到某一条数据的值为<code>'Stop'</code>字符串为止(已知里面必有一条数据为<code>'Stop'</code>字符串，但其位置不知道)。</p>
<a id="more"/>
<p>这个需求看起来很简单，于是你立刻就着手写出了代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br/><span class="line"/><br/><span class="line">client = redis.Redis()</span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span></span><br/><span class="line">    datas = []</span><br/><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br/><span class="line">        data = client.lpop().decode()</span><br/><span class="line">        <span class="keyword">if</span> data == <span class="string">'Stop'</span>:</span><br/><span class="line">            <span class="keyword">break</span></span><br/><span class="line">        datas.append(data)</span><br/><span class="line">    <span class="keyword">return</span> datas</span><br/></pre></td></tr></table></figure>
<p>现在问题来了，如果 Redis 里面的数据非常多，已经超过了你的内存容量怎么办？数据全部放在<code>datas</code>列表里面再返回显然是不可取的做法。</p>
<p>好在，这些数据读取出来以后，会传给一个<code>parse</code>函数，并且这个函数是一条一条处理数据的，它处理完成以后，就可以把数据丢弃了。</p>
<p>于是你可能会这样改写代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br/><span class="line"/><br/><span class="line">client = redis.Redis()</span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br/><span class="line">        data = client.lpop().decode()</span><br/><span class="line">        <span class="keyword">if</span> data == <span class="string">'Stop'</span>:</span><br/><span class="line">            <span class="keyword">break</span></span><br/><span class="line">        parse(data)</span><br/></pre></td></tr></table></figure>
<p>但我们知道，在编码规范和软件工程里面，建议一个函数，它应该只做一件事情，而现在<code>read_data()</code>函数却做了两件事情：1. 从 Redis 里面读取数据。2.调用<code>parse()</code>函数。</p>
<p>那么我们有没有办法把他们区分开来呢？如何让<code>read_data</code>能返回数据，但是又不会把内存撑爆呢？</p>
<p>这个时候，我们就可以使用生成器来解决问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br/><span class="line"/><br/><span class="line">client = redis.Redis()</span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br/><span class="line">        data = client.lpop().decode()</span><br/><span class="line">        <span class="keyword">if</span> data == <span class="string">'Stop'</span>:</span><br/><span class="line">            <span class="keyword">break</span></span><br/><span class="line">        <span class="keyword">yield</span> data</span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_data</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> read_data():</span><br/><span class="line">        parse(data)</span><br/></pre></td></tr></table></figure>
<p>在这个代码里面，<code>read_data</code>变成了生成器函数，它返回一个生成器，对生成器进行迭代的时候，每次返回一条数据，这一条数据立即传给<code>parse()</code>函数。整个过程源源不断，生生不息。不需要额外创建一个列表用来存放数据。</p>
<p>那么代码还能不能继续简化呢？此时我们就可以使用<code>iter</code>关键字了。</p>
<p>使用了<code>iter</code>关键字的效果如下图所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br/><span class="line"/><br/><span class="line">client = redis.Redis()</span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span></span><br/><span class="line">    data = client.lpop().decode()</span><br/><span class="line">    <span class="keyword">return</span> data</span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_data</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> iter(read_data, <span class="string">'Stop'</span>):</span><br/><span class="line">        parse(data)</span><br/></pre></td></tr></table></figure>
<p>其中，<code>read_data</code>现在每运行一次只会返回列表最左边的数据。但是当我们直接使用<code>iter(read_data, 'Stop')</code>的时候，就会得到一个<code>迭代器</code>。对这个迭代器进行迭代，相当于在<code>While True</code>里面不停运行<code>read_data</code>函数，直到某一次迭代的时候，<code>read_data</code>函数返回了<code>Stop</code>，就停止。</p>
<p>当然如果你想炫技的话，还可以进一步简化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br/><span class="line"/><br/><span class="line">client = redis.Redis()</span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_data</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: client.lpop().decode(), <span class="string">'Stop'</span>):</span><br/><span class="line">        parse(data)</span><br/></pre></td></tr></table></figure>
<p>当然，我是不推荐这样写的。</p>

      
    </div>

    

    
    
    

    
      
禁<div class="post-body" itemprop="articleBody">

      
      

      
        <p>在上一篇文章中，我们说到了，<code>itertools.tee</code>不是线程安全的，并给出了一个例子，如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-05-22-04-16.png" alt=""/></p>
<p>在两个线程里面同时运行分裂出来的生成器对象，就会导致报错。</p>
<a id="more"/>
<p>现在，你想看看<code>itertools.tee</code>的源代码，但是你会发现，在 PyCharm 里面，它的源代码如下图所示：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-06-21-55-40.png" alt=""/></p>
<p>这是因为，在 CPython 中，<code>itertools.tee</code>底层是通过C 语言实现的，所以你不能在 PyCharm 中看到它的源代码。但是你可以通过阅读 <a href="https://github.com/python/cpython/blob/master/Modules/itertoolsmodule.c" target="_blank" rel="noopener">Python 的源代码中的Modules/itertoolsmodule.c文件</a>，找到它的实现算法。</p>
<p>导致问题的核心部分在如下图所示的两段代码中：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-06-22-03-11.png" alt=""/></p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-06-22-05-19.png" alt=""/></p>
<p>大家看不懂也没有关系，根据我上一篇文章中使用 Python 实现的简化版本就足够帮助理解了。</p>
<p>我们使用简化版本来解释其中线程不安全的地方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></span><br/><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br/><span class="line">        <span class="keyword">yield</span> <span class="string">f'我是你第<span class="subst">{i}</span>个爷爷'</span></span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(g)</span>:</span></span><br/><span class="line">    value_list_1 = []</span><br/><span class="line">    value_list_2 = []</span><br/><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(queue)</span>:</span></span><br/><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br/><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue:</span><br/><span class="line">                <span class="keyword">try</span>:</span><br/><span class="line">                    value = next(g)</span><br/><span class="line">                <span class="keyword">except</span> StopIteration:</span><br/><span class="line">                    <span class="keyword">return</span></span><br/><span class="line">                value_list_1.append(value)</span><br/><span class="line">                value_list_2.append(value)</span><br/><span class="line">            <span class="keyword">yield</span> queue.pop(<span class="number">0</span>)</span><br/><span class="line">    g_1 = wrap(value_list_1)</span><br/><span class="line">    g_2 = wrap(value_list_2)</span><br/><span class="line">    <span class="keyword">return</span> g_1, g_2</span><br/><span class="line"/><br/><span class="line">g = generator()</span><br/><span class="line">g_1, g_2 = split(g)</span><br/><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_1:</span><br/><span class="line">    print(value)</span><br/><span class="line"/><br/><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> g_2:</span><br/><span class="line">    print(value)</span><br/></pre></td></tr></table></figure>
<p>当两个线程同时运行到<code>if not queue</code>时，发现当前各自的队列都是空的，于是进入<code>value = next(g)</code>获取下一个值。其中，线程 A 先进入那么几毫秒。然后线程 B 进入<code>value = next(g)</code>。但由于此时线程 A 中的<code>next(g)</code>正在运行，尚未结束，线程 B 又跑来运行，于是就导致了报错的发生。Python 中，生成器不是线程安全的。</p>
<p>那么如何让<code>itertools.tee</code>分裂出来的多个生成器可以在多线程中运行呢？其关键因素就是让<code>value = next(g)</code>这一行一次只能让一个线程运行。所以我们可以通过加锁来实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br/><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br/><span class="line"/><br/><span class="line"/><br/><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KingnameTee</span>:</span></span><br/><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tee_obj, lock)</span>:</span></span><br/><span class="line">        self.tee_obj = tee_obj</span><br/><span class="line">        self.lock = lock</span><br/><span class="line"/><br/><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br/><span class="line">        <span class="keyword">return</span> self</span><br/><span class="line">   </span><br/><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br/><span class="line">        <span class="keyword">with</span> self.lock:</span><br/><span class="line">            <span class="keyword">return</span> next(self.tee_obj)</span><br/><span class="line">    </span><br/><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__copy__</span><span class="params">(self)</span>:</span></span><br/><span class="line">        <span class="keyword">return</span> KingnameTee(self.tee_obj.__copy__(), self.lock)</span><br/><span class="line"/><br/><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_tee</span><span class="params">(iterable, n=<span class="number">2</span>)</span>:</span></span><br/><span class="line">    <span class="string">"""tuple of n independent thread-safe iterators"""</span></span><br/><span class="line">    lock = Lock()</span><br/><span class="line">    <span class="keyword">return</span> tuple(KingnameTee(tee_obj, lock) <span class="keyword">for</span> tee_obj <span class="keyword">in</span> itertools.tee(iterable, n))</span><br/></pre></td></tr></table></figure>
<p>我们来看看运行效果：</p>
<p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-11-06-22-21-01.png" alt=""/></p>
<p>多线程完美运行。</p>

      
    </div>

    

    
    
    

    
      